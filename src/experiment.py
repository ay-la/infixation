import openai
import random
import csv
import time

from modules.model_response import *
from modules.experiment_results import *
from tqdm import tqdm

openai.api_key = "API_KEY_HERE"


def generate_result(prompt: str, 
                    word: str, 
                    correct_infix: str, 
                    list_of_examples: List[tuple],
                    model_name: str):
    '''
    Creates and returns a ModelResponse object to store a text completion generated by an OpenAI model, 
    and the associated information.

    Parameters
    ----------
    prompt : str
        The prompt given to the model, including any few-shot examples.
    word : str
        The word that the model must apply infixation to.
    correct_infix : str
        The expected infixed form of the word.
    list_of_examples : List[tuple]
        The n-shot examples of words and their correctly infixed forms.
    model_name : str
        The desired OpenAI model for performing this task.
    '''
    response = ask_model(prompt, model_name)
    response_text = response.choices[0].text.strip()
    logprobs = response["choices"][0]["logprobs"]["top_logprobs"]
    return ModelResponse(word, correct_infix, list_of_examples, response_text, logprobs)


def ask_model(prompt: str, model_name: str):
    '''
    Feeds a prompt to an OpenAI model and returns the generated text completion.
    '''
    response = openai.Completion.create(
        engine=model_name,
        prompt=prompt,
        temperature=0,
        max_tokens=50,
        n=1,
        stop=None,
        timeout=10,
        logprobs=3
    )
    return response


def get_example_shots(data: List[tuple], 
                    sampled_dict: dict, 
                    test_word: str, num_shots: int):
    '''
    Creates a list of n many examples (n == num_shots).

    To avoid/minimize oversampling a particular example, examples are selected randomly from the entire data, 
    then compared with a dictionary that keeps track of how many times an example has been sampled in the experiment.
    '''
    i = 0
    examples = []

    while i < num_shots:
        random_example = random.choice(data)

        if is_valid_example(random_example, test_word, examples) and sampled_dict[random_example] == 0:
            update_examples_and_dict(random_example, examples, sampled_dict)
            i += 1  
        else:
            alternative_choice = get_least_sampled_example(sampled_dict)

            if alternative_choice:
                update_examples_and_dict(alternative_choice, examples, sampled_dict)
                i += 1

    return examples, sampled_dict


def is_valid_example(example, test_word, list_of_examples):
    '''Returns True if example is not the test word nor already in the list of examples.'''
    return example[0] != test_word and example not in list_of_examples


def get_least_sampled_example(sampled_dict, test_word, list_of_examples):
    '''Returns the least sampled example when the dictionary counting how many times an example has been sampled is sorted.'''
    sorted_dict = sorted(sampled_dict.items(), key=lambda item: item[1])
    for alternative_choice in sorted_dict:
        if is_valid_example(alternative_choice[0], test_word, list_of_examples):
            return alternative_choice[0]
    return None


def update_examples_and_dict(example, examples, sampled_dict):
    '''Updates the list of examples given to the model with a new one, 
    and increments the sample counter for that example.'''
    examples.append(example)
    sampled_dict[example] += 1


def run_experiment(num_shots: int, experiment_number: int, experiment_name: str, 
                   model_name: str, context: str, prompt_details: str, filepath: str):
    '''
    Runs an experiment.

    Creates an ExperimentResults object to store the text completions for all test words given to the model, 
    and saves the results to a file.
    '''
   
    experiment = ExperimentResults(num_shots, experiment_number, experiment_name=experiment_name, model_name=model_name)
    data = load_csv_to_list(filepath)
    sampled_dict = {item: 0 for item in data}

    for word_tup in enumerate(tqdm(data)):
        examples = [] # just to be sure that examples are getting reset..
        word = word_tup[1][0]
        correct_infix = word_tup[1][1]
        examples, sampled_dict = get_example_shots(data, sampled_dict, word, num_shots)

        prompt = f"{context}{prompt_details[0]}{word}{prompt_details[1]}{str(len(examples))}{prompt_details[2]}{get_example_str(examples)}."
        print(prompt)

        try: 
            response = generate_result(prompt, word, correct_infix, examples, model_name)
        except openai.error.RateLimitError:
            print("\nRate limit reached. Trying again in 1 min.")
            countdown(61)
            response = generate_result(prompt, word, correct_infix, examples, model_name)

        experiment.add_result(response)

    experiment.save_to_file()


def get_example_str(examples):
    '''Turns a list of n examples into a string '''
    examples = ""
    for i, example in enumerate(examples):
        if (i < len(examples) - 1):
            examples += example[0] + ": " + example[1] + ", "
        else:
            examples += example[0] + ": " + example[1]
    return examples


def load_csv_to_list(file_path):
    '''Loads a csv file of word,infix pairs as a list of (word, infix) tuples to be given to the model as examples.'''
    data = []
    with open(file_path, mode='r', encoding='utf-8') as csv_file:
        csv_reader = csv.reader(csv_file)
        for row in csv_reader:
            word = row[0]
            infix = row[1]
            data.append((word, infix))
    return data


def countdown(t):
    '''Countdown for retrying a query when rate limit is reached.'''
    while t:
        mins, secs = divmod(t, 60)
        timer = '{:02d}:{:02d}'.format(mins, secs)
        print(timer, end="\r")
        time.sleep(1)
        t -= 1


def prompt_to_continue():
    '''Just for breaks when testing the code.'''
    print()
    input("Enter to continue.")


